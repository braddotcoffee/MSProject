var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ts = require('typescript');
var Base = (function () {
    function Base() {
    }
    Base.prototype.mapNodes = function (nodes) {
        var _this = this;
        return nodes ? nodes.map(function (n) { return _this.mapNode(n); }) : [];
    };
    return Base;
})();
exports.Base = Base;
var PublicApiAggregator = (function (_super) {
    __extends(PublicApiAggregator, _super);
    function PublicApiAggregator() {
        _super.apply(this, arguments);
    }
    PublicApiAggregator.prototype.mapNode = function (node) {
        switch (node.kind) {
            case 211 /* VariableDeclaration */:
                var varDecl = node;
                var name_1 = getName(node);
                var isConst = hasFlag(varDecl.parent, 32768 /* Const */);
                var type = this.getColonType(node);
                return [((isConst ? 'const' : 'var') + " " + name_1 + type)];
            case 214 /* ClassDeclaration */:
                var classDecl = node;
                return this.getClassLike('class', classDecl);
            case 217 /* EnumDeclaration */:
                var enumDecl = node;
                return this.getClassLike('enum', enumDecl);
            case 247 /* EnumMember */:
                return [getName(node)];
            case 215 /* InterfaceDeclaration */:
                var ifDecl = node;
                return this.getClassLike('interface', ifDecl);
            case 143 /* MethodDeclaration */:
                if (this.shouldBeSkipped(node))
                    return [];
                return [this.getFunctionLike(node)];
            case 141 /* PropertyDeclaration */:
                if (this.shouldBeSkipped(node))
                    return [];
                return [this.getProperty(node)];
            case 144 /* Constructor */:
                return [
                    this.getConstructor(node)
                ].concat(this.getConstructorProperties(node));
            case 140 /* PropertySignature */:
                return [this.getProperty(node)];
            case 142 /* MethodSignature */:
                return [this.getFunctionLike(node)];
            case 145 /* GetAccessor */:
                if (this.shouldBeSkipped(node))
                    return [];
                return [this.getGetter(node)];
            case 146 /* SetAccessor */:
                if (this.shouldBeSkipped(node))
                    return [];
                return [this.getSetter(node)];
            case 213 /* FunctionDeclaration */:
                return [this.getFunctionLike(node)];
            default:
                return [];
        }
    };
    PublicApiAggregator.prototype.shouldBeSkipped = function (decl) {
        var name = decl.name;
        if (name.kind === 136 /* ComputedPropertyName */) {
            return true;
        }
        var n = getName(decl);
        return hasFlag(decl.modifiers, 32 /* Private */) || n[0] == '_';
    };
    PublicApiAggregator.prototype.getFunctionLike = function (node) {
        var name = getName(node);
        var params = this.getParameters(node.parameters);
        var retType = this.getColonType(node);
        return name + "(" + params + ")" + retType;
    };
    PublicApiAggregator.prototype.getConstructor = function (node) {
        var params = this.getParameters(node.parameters);
        return "constructor(" + params + ")";
    };
    PublicApiAggregator.prototype.getConstructorProperties = function (node) {
        var _this = this;
        var properties = [];
        node.parameters.forEach(function (p) {
            var includeProp = false;
            var accessModifier = ''; // we default to "" and not print "public" for public properties
            if (hasFlag(p, 16 /* Public */)) {
                includeProp = true;
            }
            else if (hasFlag(p, 64 /* Protected */)) {
                includeProp = true;
                accessModifier = '//protected';
            }
            if (includeProp) {
                properties.push((_this.getParameter(p) + " " + accessModifier).trim());
            }
        });
        return properties;
    };
    PublicApiAggregator.prototype.getGetter = function (node) {
        var name = getName(node);
        var type = this.getColonType(node);
        return "" + name + type;
    };
    PublicApiAggregator.prototype.getSetter = function (node) {
        var name = getName(node);
        var params = this.getParameters(node.parameters);
        return name + "=(" + params + ")";
    };
    PublicApiAggregator.prototype.getProperty = function (decl) {
        var name = getName(decl);
        var type = this.getColonType(decl);
        return "" + name + type;
    };
    PublicApiAggregator.prototype.getParameters = function (nodes) {
        var _this = this;
        return nodes.map(function (p) { return _this.getParameter(p); }).join(', ');
    };
    PublicApiAggregator.prototype.getParameter = function (node) {
        return "" + getName(node) + getOptional(node) + ":" + getType(node) + getInitializer(node);
    };
    PublicApiAggregator.prototype.getClassLike = function (keyword, decl) {
        var name = getName(decl);
        var typeParams = typesToString(decl.typeParameters);
        var nameWithTypes = typeParams ? name + "<" + typeParams + ">" : name;
        var members = this.mapNodes(decl.members);
        return [nameWithTypes].concat(flatten(members).map(function (m) { return (name + "." + m); }));
    };
    PublicApiAggregator.prototype.getColonType = function (node) {
        var type = getType(node);
        return type ? ":" + type : '';
    };
    return PublicApiAggregator;
})(Base);
exports.__esModule = true;
exports["default"] = PublicApiAggregator;
var TypeExtract = (function (_super) {
    __extends(TypeExtract, _super);
    function TypeExtract() {
        _super.apply(this, arguments);
    }
    TypeExtract.prototype.mapNode = function (node) {
        switch (node.kind) {
            case 155 /* TypeLiteral */:
                var members = node.members;
                var strMembers = [];
                for (var i = 0; i < members.length; ++i) {
                    var member = members[i];
                    var name_2 = getName(member);
                    var question = !!member.questionToken;
                    var type_1 = getType(member);
                    strMembers.push("" + name_2 + (question ? '?' : '') + ":" + type_1);
                }
                return "{" + strMembers.join(", ") + "}";
            case 158 /* UnionType */:
                return this.mapNodes(node.types).join('|');
            case 151 /* TypeReference */:
                var typeRef = node;
                var name_3 = this.mapNode(typeRef.typeName);
                var typeParams = typeRef.typeArguments ? this.mapNodes(typeRef.typeArguments).join(', ') : null;
                return typeParams ? name_3 + "<" + typeParams + ">" : name_3;
            case 137 /* TypeParameter */:
                var typeParam = node;
                return this.mapNode(typeParam.name);
            case 156 /* ArrayType */:
                var type = this.mapNode(node.elementType);
                return type + "[]";
            case 157 /* TupleType */:
                var types = this.mapNodes(node.elementTypes);
                return "[" + types.join(', ') + "]";
            case 152 /* FunctionType */:
                return node.getText();
            case 135 /* QualifiedName */:
                var first = node;
                return this.mapNode(first.right);
            case 69 /* Identifier */:
                var ident = node;
                return ident.text;
            case 128 /* NumberKeyword */:
                return 'number';
            case 130 /* StringKeyword */:
                return 'string';
            case 103 /* VoidKeyword */:
                return 'void';
            case 120 /* BooleanKeyword */:
                return 'boolean';
            case 117 /* AnyKeyword */:
                return 'any';
            default:
                return 'unknown';
        }
    };
    return TypeExtract;
})(Base);
function typeToString(node) {
    return node ? new TypeExtract().mapNode(node) : null;
}
function typesToString(nodes) {
    return nodes ? new TypeExtract().mapNodes(nodes).join(',') : null;
}
function hasFlag(n, flag) {
    return n && (n.flags & flag) !== 0 || false;
}
function reportError(n, message) {
    var file = n.getSourceFile();
    var fileName = file.fileName;
    var start = n.getStart(file);
    var pos = file.getLineAndCharacterOfPosition(start);
    // Line and character are 0-based.
    var fullMessage = fileName + ":" + (pos.line + 1) + ":" + (pos.character + 1) + ": " + message;
    throw new Error(fullMessage);
}
function flatten(nestedArray) {
    return nestedArray.reduce(function (a, b) { return a.concat(b); }, []);
}
function getName(node) {
    var name = node.name;
    if (name) {
        return removeSpaces(name.getText());
    }
    else if (node.kind === 149 /* IndexSignature */) {
        var sig = node;
        return "[" + removeSpaces(sig.parameters[0].getText()) + "]";
    }
    else {
        reportError(node, 'Cannot get name');
    }
}
function getOptional(node) {
    return (node.questionToken) ? '?' : '';
}
function getType(node) {
    var t = typeToString(node.type);
    return t ? t : 'any';
}
function getInitializer(node) {
    if (node.initializer) {
        return '=' + node.initializer.getText();
    }
    else {
        return '';
    }
}
function removeSpaces(s) {
    return s.replace(/\s+/g, '');
}

//# sourceMappingURL=api_aggregator.js.map
