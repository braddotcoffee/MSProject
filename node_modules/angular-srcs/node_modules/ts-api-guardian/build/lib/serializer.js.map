{"version":3,"sources":["serializer.ts"],"names":["publicApi","publicApiInternal","ResolvedDeclarationEmitter","ResolvedDeclarationEmitter.constructor","ResolvedDeclarationEmitter.emit","ResolvedDeclarationEmitter.getResolvedSymbols","ResolvedDeclarationEmitter.emitNode","symbolCompareFunction","compareFunction","stripEmptyLines","getFirstQualifier","createErrorMessage"],"mappings":"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","file":"serializer.js","sourcesContent":["import * as path from 'path';\nimport * as ts from 'typescript';\n\nconst baseTsOptions: ts.CompilerOptions = {\n  // We don't want symbols from external modules to be resolved, so we use the\n  // classic algorithm.\n  moduleResolution: ts.ModuleResolutionKind.Classic\n};\n\nexport interface SerializationOptions {\n  /**\n   * Removes all exports matching the regular expression.\n   */\n  stripExportPattern?: RegExp;\n  /**\n   * Whitelists these identifiers as modules in the output. For example,\n   * ```\n   * import * as angular from './angularjs';\n   *\n   * export class Foo extends angular.Bar {}\n   * ```\n   * will produce `export class Foo extends angular.Bar {}` and requires\n   * whitelisting angular.\n   */\n  allowModuleIdentifiers?: string[];\n  /**\n   * Warns or errors if stability annotations are missing on an export.\n   * Supports experimental, stable and deprecated.\n   */\n  onStabilityMissing?: string;  // 'warn' | 'error' | 'none'\n}\n\nexport function publicApi(fileName: string, options: SerializationOptions = {}): string {\n  return publicApiInternal(ts.createCompilerHost(baseTsOptions), fileName, baseTsOptions, options);\n}\n\nexport function publicApiInternal(\n    host: ts.CompilerHost, fileName: string, tsOptions: ts.CompilerOptions,\n    options: SerializationOptions = {}): string {\n  const entrypoint = path.normalize(fileName);\n\n  if (!entrypoint.match(/\\.d\\.ts$/)) {\n    throw new Error(`Source file \"${fileName}\" is not a declaration file`);\n  }\n\n  const program = ts.createProgram([entrypoint], tsOptions, host);\n  return new ResolvedDeclarationEmitter(program, entrypoint, options).emit();\n}\n\ninterface Diagnostic {\n  type: string;  // 'warning' | 'error'\n  message: string;\n}\n\nclass ResolvedDeclarationEmitter {\n  private program: ts.Program;\n  private fileName: string;\n  private typeChecker: ts.TypeChecker;\n  private options: SerializationOptions;\n  private diagnostics: Diagnostic[];\n\n  constructor(program: ts.Program, fileName: string, options: SerializationOptions) {\n    this.program = program;\n    this.fileName = fileName;\n    this.options = options;\n    this.diagnostics = [];\n\n    this.typeChecker = this.program.getTypeChecker();\n  }\n\n  emit(): string {\n    const sourceFile = this.program.getSourceFiles().filter(sf => sf.fileName === this.fileName)[0];\n    if (!sourceFile) {\n      throw new Error(`Source file \"${this.fileName}\" not found`);\n    }\n\n    let output = '';\n\n    const resolvedSymbols = this.getResolvedSymbols(sourceFile);\n    // Sort all symbols so that the output is more deterministic\n    resolvedSymbols.sort(symbolCompareFunction);\n\n    for (const symbol of resolvedSymbols) {\n      if (this.options.stripExportPattern && symbol.name.match(this.options.stripExportPattern)) {\n        continue;\n      }\n\n      let decl: ts.Node = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];\n      if (!decl) {\n        this.diagnostics.push({\n          type: 'warning',\n          message: `${sourceFile.fileName}: error: No declaration found for symbol \"${symbol.name}\"`\n        });\n        continue;\n      }\n\n      // The declaration node may not be a complete statement, e.g. for var/const\n      // symbols. We need to find the complete export statement by traversing\n      // upwards.\n      while (!(decl.flags & ts.NodeFlags.Export) && decl.parent) {\n        decl = decl.parent;\n      }\n      if (decl.flags & ts.NodeFlags.Export) {\n        // Make an empty line between two exports\n        if (output) {\n          output += '\\n';\n        }\n\n        // Print stability annotation\n        const sourceText = decl.getSourceFile().text;\n        const trivia = sourceText.substr(decl.pos, decl.getLeadingTriviaWidth());\n        const match = stabilityAnnotationPattern.exec(trivia);\n        if (match) {\n          output += `/** @${match[1]} */\\n`;\n        } else if (['warn', 'error'].indexOf(this.options.onStabilityMissing) >= 0) {\n          this.diagnostics.push({\n            type: this.options.onStabilityMissing,\n            message: createErrorMessage(\n                decl, `No stability annotation found for symbol \"${symbol.name}\"`)\n          });\n        }\n\n        output += stripEmptyLines(this.emitNode(decl)) + '\\n';\n      } else {\n        // This may happen for symbols re-exported from external modules.\n        this.diagnostics.push({\n          type: 'warning',\n          message:\n              createErrorMessage(decl, `No export declaration found for symbol \"${symbol.name}\"`)\n        });\n      }\n    }\n\n    if (this.diagnostics.length) {\n      const message = this.diagnostics.map(d => d.message).join('\\n');\n      console.warn(message);\n      if (this.diagnostics.some(d => d.type === 'error')) {\n        throw new Error(message);\n      }\n    }\n\n    return output;\n  }\n\n  private getResolvedSymbols(sourceFile: ts.SourceFile): ts.Symbol[] {\n    const ms = (<any>sourceFile).symbol;\n    const rawSymbols = ms ? (this.typeChecker.getExportsOfModule(ms) || []) : [];\n    return rawSymbols.map(s => {\n      if (s.flags & ts.SymbolFlags.Alias) {\n        const resolvedSymbol = this.typeChecker.getAliasedSymbol(s);\n\n        // This will happen, e.g. for symbols re-exported from external modules.\n        if (!resolvedSymbol.valueDeclaration && !resolvedSymbol.declarations) {\n          return s;\n        }\n        if (resolvedSymbol.name !== s.name) {\n          throw new Error(\n              `Symbol \"${resolvedSymbol.name}\" was aliased as \"${s.name}\". ` +\n              `Aliases are not supported.\"`);\n        }\n\n        return resolvedSymbol;\n      } else {\n        return s;\n      }\n    });\n  }\n\n  emitNode(node: ts.Node) {\n    if (node.flags & ts.NodeFlags.Private) {\n      return '';\n    }\n\n    const firstQualifier: ts.Identifier = getFirstQualifier(node);\n\n    if (firstQualifier) {\n      if (!this.options.allowModuleIdentifiers ||\n          this.options.allowModuleIdentifiers.indexOf(firstQualifier.text) < 0) {\n        this.diagnostics.push({\n          type: 'error',\n          message: createErrorMessage(\n              firstQualifier,\n              `Module identifier \"${firstQualifier.text}\" is not allowed. Remove it ` +\n                  `from source or whitelist it via --allowModuleIdentifiers.`)\n        });\n      }\n    }\n\n    let children = node.getChildren();\n    const sourceText = node.getSourceFile().text;\n    if (children.length) {\n      // Sort declarations under a class or an interface\n      if (node.kind === ts.SyntaxKind.SyntaxList) {\n        switch (node.parent && node.parent.kind) {\n          case ts.SyntaxKind.ClassDeclaration:\n          case ts.SyntaxKind.InterfaceDeclaration: {\n            // There can be multiple SyntaxLists under a class or an interface,\n            // since SyntaxList is just an arbitrary data structure generated\n            // by Node#getChildren(). We need to check that we are sorting the\n            // right list.\n            if (children.every(node => node.kind in memberDeclarationOrder)) {\n              children = children.slice();\n              children.sort((a: ts.Declaration, b: ts.Declaration) => {\n                // Static after normal\n                return compareFunction(\n                           a.flags & ts.NodeFlags.Static, b.flags & ts.NodeFlags.Static) ||\n                    // Our predefined order\n                    compareFunction(\n                           memberDeclarationOrder[a.kind], memberDeclarationOrder[b.kind]) ||\n                    // Alphebetical order\n                    // We need safe dereferencing due to edge cases, e.g. having two call signatures\n                    compareFunction((a.name || a).getText(), (b.name || b).getText());\n              });\n            }\n            break;\n          }\n        }\n      }\n\n      let output = children.map(n => this.emitNode(n)).join('');\n\n      // Print stability annotation for fields\n      if (node.kind in memberDeclarationOrder) {\n        const trivia = sourceText.substr(node.pos, node.getLeadingTriviaWidth());\n        const match = stabilityAnnotationPattern.exec(trivia);\n        if (match) {\n          // Add the annotation after the leading whitespace\n          output = output.replace(/^(\\n\\s*)/, `$1/** @${match[1]} */ `);\n        }\n      }\n\n      return output;\n    } else {\n      const ranges = ts.getLeadingCommentRanges(sourceText, node.pos);\n      let tail = node.pos;\n      for (const range of ranges || []) {\n        if (range.end > tail) {\n          tail = range.end;\n        }\n      }\n      return sourceText.substring(tail, node.end);\n    }\n  }\n}\n\nfunction symbolCompareFunction(a: ts.Symbol, b: ts.Symbol) {\n  return a.name.localeCompare(b.name);\n}\n\nfunction compareFunction<T>(a: T, b: T) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nconst memberDeclarationOrder = {\n  [ts.SyntaxKind.PropertySignature]: 0,\n  [ts.SyntaxKind.PropertyDeclaration]: 0,\n  [ts.SyntaxKind.GetAccessor]: 0,\n  [ts.SyntaxKind.SetAccessor]: 0,\n  [ts.SyntaxKind.CallSignature]: 1,\n  [ts.SyntaxKind.Constructor]: 2,\n  [ts.SyntaxKind.ConstructSignature]: 2,\n  [ts.SyntaxKind.IndexSignature]: 3,\n  [ts.SyntaxKind.MethodSignature]: 4,\n  [ts.SyntaxKind.MethodDeclaration]: 4\n};\n\nconst stabilityAnnotationPattern = /@(experimental|stable|deprecated)\\b/;\n\nfunction stripEmptyLines(text: string): string {\n  return text.split('\\n').filter(x => !!x.length).join('\\n');\n}\n\n/**\n * Returns the first qualifier if the input node is a dotted expression.\n */\nfunction getFirstQualifier(node: ts.Node): ts.Identifier {\n  if (node.kind === ts.SyntaxKind.PropertyAccessExpression) {\n    // For expression position\n    let lhs: ts.Node = node;\n    do {\n      lhs = (<ts.PropertyAccessExpression>lhs).expression;\n    } while (lhs && lhs.kind !== ts.SyntaxKind.Identifier);\n\n    return <ts.Identifier>lhs;\n\n  } else if (node.kind === ts.SyntaxKind.TypeReference) {\n    // For type position\n    let lhs: ts.Node = (<ts.TypeReferenceNode>node).typeName;\n    do {\n      lhs = (<ts.QualifiedName>lhs).left;\n    } while (lhs && lhs.kind !== ts.SyntaxKind.Identifier);\n\n    return <ts.Identifier>lhs;\n\n  } else {\n    return null;\n  }\n}\n\nfunction createErrorMessage(node: ts.Node, message: string): string {\n  const sourceFile = node.getSourceFile();\n  let position;\n  if (sourceFile) {\n    const {line, character} = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n    position = `${sourceFile.fileName}(${line + 1},${character + 1})`;\n  } else {\n    position = '<unknown>';\n  }\n\n  return `${position}: error: ${message}`;\n}\n"],"sourceRoot":"/source/"}