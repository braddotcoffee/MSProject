{
  "_args": [
    [
      {
        "raw": "memoizeasync@https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.8.0.tgz",
        "scope": null,
        "escapedName": "memoizeasync",
        "name": "memoizeasync",
        "rawSpec": "https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.8.0.tgz",
        "spec": "https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.8.0.tgz",
        "type": "remote"
      },
      "/home/bwbonanno/Documents/Websites/Confessions/SourceCode/node_modules/angular-srcs"
    ]
  ],
  "_from": "memoizeasync@0.8.0",
  "_id": "memoizeasync@0.8.0",
  "_inCache": true,
  "_location": "/angular-srcs/memoizeasync",
  "_phantomChildren": {},
  "_requested": {
    "raw": "memoizeasync@https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.8.0.tgz",
    "scope": null,
    "escapedName": "memoizeasync",
    "name": "memoizeasync",
    "rawSpec": "https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.8.0.tgz",
    "spec": "https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.8.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/angular-srcs",
    "/angular-srcs/cldr"
  ],
  "_resolved": "https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.8.0.tgz",
  "_shasum": "dae48739655e61de56631080c0aa9131ca16e7d4",
  "_shrinkwrap": null,
  "_spec": "memoizeasync@https://registry.npmjs.org/memoizeasync/-/memoizeasync-0.8.0.tgz",
  "_where": "/home/bwbonanno/Documents/Websites/Confessions/SourceCode/node_modules/angular-srcs",
  "author": {
    "name": "Andreas Lind Petersen",
    "email": "andreas@one.com"
  },
  "bugs": {
    "url": "https://github.com/papandreou/node-memoizeasync/issues"
  },
  "dependencies": {
    "lru-cache": "2.5.0",
    "passerror": "0.0.2"
  },
  "description": "Helper for memoizing async functions and methods",
  "devDependencies": {
    "async": "0.9.0",
    "coveralls": "2.11.2",
    "istanbul": "0.3.2",
    "jshint": "2.5.6",
    "mocha": "1.21.5",
    "sinon": "1.10.3",
    "unexpected": "5.0.0-beta9",
    "unexpected-sinon": "3.0.2"
  },
  "directories": {
    "test": "test"
  },
  "homepage": "https://github.com/papandreou/node-memoizeasync#readme",
  "keywords": [
    "memo",
    "memoize",
    "async",
    "cache"
  ],
  "license": "BSD",
  "main": "lib/memoizeAsync.js",
  "name": "memoizeasync",
  "optionalDependencies": {},
  "readme": "node-memoizeasync\n=================\n\nYet another memoizer for asynchronous functions.\n\n[![NPM version](https://badge.fury.io/js/memoizeasync.png)](http://badge.fury.io/js/memoizeasync)\n[![Build Status](https://travis-ci.org/papandreou/node-memoizeasync.svg?branch=master)](https://travis-ci.org/papandreou/node-memoizeasync)\n[![Coverage Status](https://coveralls.io/repos/papandreou/node-memoizeasync/badge.png)](https://coveralls.io/r/papandreou/node-memoizeasync)\n[![Dependency Status](https://david-dm.org/papandreou/node-memoizeasync.png)](https://david-dm.org/papandreou/node-memoizeasync)\n\n```javascript\nvar memoizeAsync = require('memoizeasync');\n\nfunction myExpensiveComputation(arg1, arg2, cb) {\n   // ...\n   cb(null, result);\n}\n\nvar memoized = memoizeAsync(myExpensiveComputation);\n```\n\nNow `memoized` works exactly like `myExpensiveComputation`, except that\nthe actual computation is only performed once for each unique set of\narguments (apart from the callback):\n\n```javascript\nmemoized(42, 100, function (err, result) {\n    // Got the result!\n\n    memoized(42, 100, function (err, result) {\n        // Got the same result, and much faster this time!\n    });\n});\n```\n\nThe function returned by `memoizeAsync` invokes the wrapped function\nin the context it's called in itself, so `memoizeAsync` even works for\nmemoizing a method that has access to instance variables:\n\n```javascript\nfunction Foo(name) {\n    this.name = name;\n\n    this.myMethod = memoizeAsync(function (arg1, arg2, cb) {\n        console.log(\"Cool, this.name works here!\", this.name);\n        // ...\n        cb(null, \"That was tough, but I'm done now!\");\n    });\n}\n```\n\n(Unfortunately setting `Foo.prototype.myMethod = memoizeSync(...)`\nwouldn't work as the memoizer would be shared among all instances of\n`Foo`).\n\nTo distinguish different invocations (whose results need to be cached\nseparately) `memoizeAsync` relies on a naive stringification of the\narguments, which is looked up in an internally kept hash. If the\nfunction you're memoizing takes non-primitive arguments you might want\nto provide a custom `argumentsStringifier` as an option in the second\nargument to `memoizeAsync`. Otherwise all object arguments will be\nconsidered equal because they stringify to `[object Object]`:\n\n```javascript\nvar memoized = memoizeAsync(function functionToMemoize(obj, cb) {\n    // ...\n    cb(null, Object.keys(obj).join(''));\n}, {\n    argumentsStringifier: function (args) {\n       return args.map(function (arg) {return JSON.stringify(arg);}).join(\",\");\n    }\n);\n\nmemoized({foo: 'bar'}, function (err, result) {\n    // result === 'foo'\n    memoized({quux: 'baz'}), function (err, result) {\n        // result === 'quux'\n    });\n});\n```\n\nHad the custom `argumentsStringifier` not been provided, `result`\nwould have been `foo` both times.\n\nCheck out <a\nhref=\"https://github.com/papandreou/node-memoizeasync/blob/master/test/memoizeAsync.js\">the\ncustom argumentsStringifier test</a> for another example.\n\n\n### Purging and expiring memoized values ###\n\nYou can forcefully clear a specific memoized value using the `purge`\nmethod on the memoizer:\n\n```javascript\nvar memoized = memoizeAsync(function functionToMemoize(foo, cb) {\n    // ...\n    cb(null, theResult);\n});\nmemoized(123, function (err, value) {\n    memoized.purge(123);\n});\n```\n\n`memoized.purgeAll()` clears all memoized results.\n\nYou can also specify a custom ttl (in milliseconds) on the memoized\nresults:\n\n```javascript\nvar memoized = memoizeAsync(function functionToMemoize(cb) {\n    // ...\n    cb(null, theResult);\n}, {maxAge: 1000});\n```\n\nIn the above example the memoized value will be considered stale one\nsecond after it has been computed, and it will be recomputed next time\n`memoizeAsync` is invoked with the same arguments.\n\n`memoizeAsync` uses <a\nhref=\"https://github.com/isaacs/node-lru-cache\">node-lru-cache</a> to\nstore the memoized values, and it accepts the same parameters in the\n`options` object. If provided, the `length` function will be wrapped\nso it's called with the same arguments as the callback to the memoized\nfunction:\n\n```javascript\nvar fs = require('fs'),\n    memoizedFsReadFile = memoizeAsync(fs.readFile, {\n        max: 1000000,\n        length: function (err, body) {\n            return body.length;\n        },\n        maxAge: 1000\n    });\n```\n\nThe LRU instance is exposed in the `cache` property of the memoized\nfunction in case you need to access it. Note that the values stored in\nthe cache are arrays of parameters provided to the callback by the\nmemoized function. In most cases that will be `[err, result]`:\n\n\n```javascript\nvar numMemoizedErrors = 0;\nmemoized.cache.values().forEach(function (resultCallbackParams) {\n    if (resultCallbackParams[0]) {\n        numMemoizedErrors += 1;\n    }\n});\n```\n\nBesides the maxAge option that is provided by the LRU module, the\nmemoizer is augmented with a refreshAge option. When the memoizer\nis asked for a value which is post its refreshAge, it will start\nfetching a new value, while in the meantime it will return the\nvalue.\n\n```javascript\nvar memoizedFsReadFile = memoizeAsync(slowAsyncMethod, {\n        refreshAge: 900,\n        maxAge: 1000\n    });\n```\n\nError handling\n--------------\n\nIf a memoized function passes an error to its callback, memoizeAsync will catch\nand rethrow it, so memoizeAsync is transparent in that regard. By default,\nerrors won't be saved in the cache, so the original function will be run\nagain on the next invocation of the memoized function. If you want errors\nto be memoized as well, set the `errors` option to `true`.\n\nInstallation\n------------\n\nMake sure you have node.js and npm installed, then run:\n\n    npm install memoizeasync\n\nBrowser compatibility\n---------------------\n\n`memoizeAsync` uses the UMD wrapper, so it should also work in\nbrowsers. You should also have the <a\nhref=\"https://github.com/isaacs/node-lru-cache\">node-lru-cache</a>\nincluded:\n\n```html\n<script src=\"lru-cache.js\"></script>\n<script src=\"memoizeAsync.js\"></script>\n<script>\n    var memoizedFunction = memoizeAsync(function (cb) {\n        // ...\n    });\n</script>\n```\n\n`lru-cache` uses `Object.defineProperty` and doesn't include an UMD\nwrapper, but if you define a `shims` config it should be possible to\nget it memoizeAsync working with require.js, at least in newer browsers.\n\nLicense\n-------\n\n3-clause BSD license -- see the `LICENSE` file for details.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/papandreou/node-memoizeasync.git"
  },
  "scripts": {
    "coverage": "NODE_ENV=development istanbul cover _mocha -- --reporter dot",
    "lint": "jshint .",
    "prepublish": "mocha",
    "test": "mocha && npm run lint",
    "travis": "npm test && npm run coverage && <coverage/lcov.info coveralls"
  },
  "version": "0.8.0"
}
